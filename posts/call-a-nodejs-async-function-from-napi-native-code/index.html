<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Call a Nodejs Async Function from C++ Native Code | Just for fun</title><meta name=keywords content="nodejs,c++,pulsar"><meta name=description content="Nodejs Asynchronous programming is an essential part of building efficient and user-friendly Node.js applications. However, properly handling asynchronous code in a Node addon for a Node.js application can be challenging. This blog will talk about how to call a Nodejs asynchronous function in the C++ Native code
Let&rsquo;s introduce the case we have encountered first. We are attempting to use a Pulsar consumer message listener from C++ native code to call a Node."><meta name=author content="Zike Yang"><link rel=canonical href=https://zikeyang.com/posts/call-a-nodejs-async-function-from-napi-native-code/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href="https://avatars.githubusercontent.com/u/16974619?v=4"><link rel=icon type=image/png sizes=16x16 href=https://zikeyang.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zikeyang.com/favicon-32x32.png><link rel=apple-touch-icon href="https://avatars.githubusercontent.com/u/16974619?v=4"><link rel=mask-icon href="https://avatars.githubusercontent.com/u/16974619?v=4"><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-KKWDGMFRD3"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KKWDGMFRD3",{anonymize_ip:!1})}</script><meta property="og:title" content="Call a Nodejs Async Function from C++ Native Code"><meta property="og:description" content="Nodejs Asynchronous programming is an essential part of building efficient and user-friendly Node.js applications. However, properly handling asynchronous code in a Node addon for a Node.js application can be challenging. This blog will talk about how to call a Nodejs asynchronous function in the C++ Native code
Let&rsquo;s introduce the case we have encountered first. We are attempting to use a Pulsar consumer message listener from C++ native code to call a Node."><meta property="og:type" content="article"><meta property="og:url" content="https://zikeyang.com/posts/call-a-nodejs-async-function-from-napi-native-code/"><meta property="og:image" content="https://i.morioh.com/2019/10/31/8e92c75fdd2a.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-14T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-14T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://i.morioh.com/2019/10/31/8e92c75fdd2a.jpg"><meta name=twitter:title content="Call a Nodejs Async Function from C++ Native Code"><meta name=twitter:description content="Nodejs Asynchronous programming is an essential part of building efficient and user-friendly Node.js applications. However, properly handling asynchronous code in a Node addon for a Node.js application can be challenging. This blog will talk about how to call a Nodejs asynchronous function in the C++ Native code
Let&rsquo;s introduce the case we have encountered first. We are attempting to use a Pulsar consumer message listener from C++ native code to call a Node."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://zikeyang.com/posts/"},{"@type":"ListItem","position":3,"name":"Call a Nodejs Async Function from C++ Native Code","item":"https://zikeyang.com/posts/call-a-nodejs-async-function-from-napi-native-code/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Call a Nodejs Async Function from C++ Native Code","name":"Call a Nodejs Async Function from C\u002b\u002b Native Code","description":"Nodejs Asynchronous programming is an essential part of building efficient and user-friendly Node.js applications. However, properly handling asynchronous code in a Node addon for a Node.js application can be challenging. This blog will talk about how to call a Nodejs asynchronous function in the C++ Native code\nLet\u0026rsquo;s introduce the case we have encountered first. We are attempting to use a Pulsar consumer message listener from C++ native code to call a Node.","keywords":["nodejs","c++","pulsar"],"articleBody":"Nodejs Asynchronous programming is an essential part of building efficient and user-friendly Node.js applications. However, properly handling asynchronous code in a Node addon for a Node.js application can be challenging. This blog will talk about how to call a Nodejs asynchronous function in the C++ Native code\nLet’s introduce the case we have encountered first. We are attempting to use a Pulsar consumer message listener from C++ native code to call a Node.js function when triggered events occur in the Pulsar consumer. The interface of this message listener is part of the Pulsar C client library, and we have set up a C++ function to hook this listener. The user function, which is a Node.js function, will be called in that C++ function. Here is a simplified workflow for this use case:\nPulsar consumer receives the trigger event Pulsar consumer notifies the message listener written in C++ native code The message listener calls the JS function The user JS function processes the event asynchronously The message listener waits for the completion of the JS function Everything works as expected when the user JS function is synchronous. However, when we try to use asynchronous functions like the following:\nlistener: async (message, messageConsumer) =\u003e { await new Promise((resolve) =\u003e setTimeout(resolve, 10)); consumer1Recv += 1; await messageConsumer.acknowledge(message); }, The message listener does not wait for the completion of the user JS function. This is because the asynchronous JS function returns a promise object and executes the logic asynchronously. As a result, step 5 is actually waiting for the promise object instead of the completion of the user JS function.\nThis blog post discusses how to resolve this issue. We need to first determine when the user JS function has completed and then figure out how to set a guard in the C++ native code to wait until the user JS function has fully completed. And we will also talk about how to handle errors properly.\nThe Workflow for Invoking the JS Function Let’s start by taking a look at the overview of the workflow for invoking the JS function. We added a configure method to allow users to pass their JS callback function to the C++ native code:\nNapi::Function jsFunction; Napi::ThreadSafeFunction callback = Napi::ThreadSafeFunction::New( consumerConfig.Env(), jsFunction, \"Listener Callback\", 1, 1, (void *)NULL, FinalizeListenerCallback, listener); Assuming that jsFunction is passed from the user JS code, we create a ThreadSafeFunction for this jsFunction. The Napi::ThreadSafeFunction type provides APIs for threads to communicate with the Nodejs’s main thread to invoke JavaScript functions on their behalf. [0] For more documentation on Napi::ThreadSafeFunction::New, check here.\nWhen a triggered event occurs, we invoke the callback that we created above in our implementation of the message listener:\ncallback.BlockingCall(dataPtr, MessageListenerProxy); callback.Release(); When calling the BlockingCall, the current thread will be blocked until the actual invoking of the JS function becomes available in the queue inside the Node.js thread. [1] The MessageListenerProxy is a pointer to a function that we will call the internal JS function.\nHere is the simplified implementation of our MessageListenerProxy:\nvoid MessageListenerProxy(Napi::Env env, Napi::Function jsCallback, MessageListenerProxyData *data) { Napi::Object msg = Message::NewInstance({}, data-\u003ecMessage); jsCallback.Call({ msg }}); } The above is an overview of the workflow. The issue arises from jsCallback.Call({ msg }});. When the jsCallback is an asynchronous function, the jsCallback.Call({ msg }}) will return immediately instead of waiting for the user function to complete. [2]\nUse Nodejs Promise to reach the point where the user function is finished Fortunately, the jsCallback.Call will return a Node.js Promise object for us to handle if the function is asynchronous. We can handle the Promise the same way we did in JavaScript. There is an inner method in Promise called then. We can use it to register a callback for the Promise.\nHere is how to achieve it:\nNapi::Value ret = jsCallback.Call({msg}); if (ret.IsPromise()) { Napi::Promise promise = ret.As\u003cNapi::Promise\u003e(); Napi::Value thenValue = promise.Get(\"then\"); Napi::Function then = thenValue.As\u003cNapi::Function\u003e(); Napi::Function callback = Napi::Function::New(env, [](const Napi::CallbackInfo \u0026info) { // the point where the user function is finished }); then.Call(promise, {callback}); } We need to check if the return value is a Promise or not to also handle the case of a synchronous function. We create a new Napi::Function as a callback. Then we register it to Promise.then().\nUse std::promise to Wait for the Result Now, we can use std::promise to set up a guard for it. Here is a simple sample code to set up a guard:\nstd::promise\u003cvoid\u003e promise; std::future\u003cvoid\u003e future = promise.get_future(); Napi::Function callback = Napi::Function::New(env, [\u0026promise](const Napi::CallbackInfo \u0026info) { promise.set_value(); }); then.Call(promise, {callback}); // Will be blocked until the jsCallback is finished. future.wait(); It looks like we can now wait for the result of the asynchronous JS function. However, this code is also incorrect. It will block the entire main thread of the Node.js! Running this code will block your entire program.\nDon’t Wait in the Node.js Thread To fix the above problem, we need to understand the thread context changes throughout the workflow.\nThe message listener is running on the thread coming from the listener thread pool inside the Pulsar C client library. Then we use ThreadSafeFunction to change the calling context into a more thread-safe context: the Node.js main thread context. We are calling the inner JS function on the Node.js main thread. Therefore, we need to wait for the std::future outside the Node.js main thread.\nWe need to move the guard that we set above to the message listener implementation.\nstd::promise\u003cvoid\u003e promise; std::future\u003cvoid\u003e future = promise.get_future(); MessageListenerProxyData *dataPtr = new MessageListenerProxyData(cMessage, [\u0026promise]() { promise.set_value(); }); listenerCallback-\u003ecallback.BlockingCall(dataPtr, MessageListenerProxy); listenerCallback-\u003ecallback.Release(); future.wait(); delete dataPtr; We use MessageListenerProxyData to pass the lambda callback to MessageListenerProxy. And in MessageListenerProxy, we can simply call this callback:\nvoid MessageListenerProxy(Napi::Env env, Napi::Function jsCallback, MessageListenerProxyData *data) { Napi::Object msg = Message::NewInstance({}, data-\u003ecMessage); Napi::Value ret = jsCallback.Call({msg, consumer-\u003eValue()}); if (ret.IsPromise()) { Napi::Promise promise = ret.As\u003cNapi::Promise\u003e(); Napi::Value thenValue = promise.Get(\"then\"); if (thenValue.IsFunction()) { Napi::Function then = thenValue.As\u003cNapi::Function\u003e(); Napi::Function callback = Napi::Function::New(env, [data](const Napi::CallbackInfo \u0026info) { data-\u003ecallback(); }); then.Call(promise, {callback}); return; } } data-\u003ecallback(); } Note that we also set the guard even if the jsCallback is a synchronous function. Because we can’t determine if it’s synchronous or not before executing the BlockingCall. So we still need to execute data-\u003ecallback() when it’s synchronous.\nError handling Similarly, we can also use promise.catch() to handle the error that is thrown from the Nodejs code asynchronously.\nNapi::Function catchFunc = promise.Get(\"catch\").As\u003cNapi::Function\u003e(); ret = catchFunc.Call(promise, {Napi::Function::New(env, [](const Napi::CallbackInfo \u0026info) { Napi::Error error = info[0].As\u003cNapi::Error\u003e(); LOG_INFO(error.what()) data-\u003ecallback(); })}); Here, we use info[0].As() to get the first parameter of promise.catch() which is of type Error. error.what() will return the message of the error.\nFinally, we can optimize our code by moving the data-\u003ecallback to the promise.finally() to avoid calling the data-\u003ecallback twice:\npromise = ret.As\u003cNapi::Promise\u003e(); Napi::Function finallyFunc = promise.Get(\"finally\").As\u003cNapi::Function\u003e(); finallyFunc.Call( promise, {Napi::Function::New(env, [data](const Napi::CallbackInfo \u0026info) { data-\u003ecallback(); })}); In conclusion, properly handling asynchronous code in a C++ addon for a Node.js application can be tricky. It requires understanding the thread context changes and properly managing Promise objects and guards. By using ThreadSafeFunction and std::promise, we can ensure that our addon is thread-safe and does not block the Node.js main thread. Properly handling asynchronous code in a C++ addon is essential for creating efficient and reliable Node.js applications.\n","wordCount":"1199","inLanguage":"en","image":"https://i.morioh.com/2019/10/31/8e92c75fdd2a.jpg","datePublished":"2023-04-14T00:00:00Z","dateModified":"2023-04-14T00:00:00Z","author":{"@type":"Person","name":"Zike Yang"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zikeyang.com/posts/call-a-nodejs-async-function-from-napi-native-code/"},"publisher":{"@type":"Organization","name":"Just for fun","logo":{"@type":"ImageObject","url":"https://avatars.githubusercontent.com/u/16974619?v=4"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zikeyang.com accesskey=h title="Home (Alt + H)"><img src=https://zikeyang.com/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zikeyang.com>Home</a>&nbsp;»&nbsp;<a href=https://zikeyang.com/posts/>Posts</a></div><h1 class=post-title>Call a Nodejs Async Function from C++ Native Code</h1><div class=post-meta><span title='2023-04-14 00:00:00 +0000 UTC'>April 14, 2023</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1199 words&nbsp;·&nbsp;Zike Yang</div></header><figure class=entry-cover><img loading=lazy src=https://i.morioh.com/2019/10/31/8e92c75fdd2a.jpg alt=Nodejs+CPP></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#the-workflow-for-invoking-the-js-function>The Workflow for Invoking the JS Function</a></li><li><a href=#use-nodejs-promise-to-reach-the-point-where-the-user-function-is-finished>Use Nodejs <code>Promise</code> to reach the point where the user function is finished</a></li><li><a href=#use-stdpromise-to-wait-for-the-result>Use <code>std::promise</code> to Wait for the Result</a></li><li><a href=#dont-wait-in-the-nodejs-thread>Don&rsquo;t Wait in the Node.js Thread</a></li><li><a href=#error-handling>Error handling</a></li></ul></nav></div></details></div><div class=post-content><p>Nodejs Asynchronous programming is an essential part of building efficient and user-friendly Node.js applications. However, properly handling asynchronous code in a Node addon for a Node.js application can be challenging. This blog will talk about how to call a Nodejs asynchronous function in the C++ Native code</p><p>Let&rsquo;s introduce the case we have encountered first. We are attempting to use a Pulsar consumer message listener from C++ native code to call a Node.js function when triggered events occur in the Pulsar consumer. The interface of this message listener is part of the Pulsar C client library, and we have set up a C++ function to hook this listener. The user function, which is a Node.js function, will be called in that C++ function. Here is a simplified workflow for this use case:</p><ol><li>Pulsar consumer receives the trigger event</li><li>Pulsar consumer notifies the message listener written in C++ native code</li><li>The message listener calls the JS function</li><li>The user JS function processes the event asynchronously</li><li>The message listener waits for the completion of the JS function</li></ol><p>Everything works as expected when the user JS function is synchronous. However, when we try to use asynchronous functions like the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>listener</span><span class=o>:</span> <span class=kr>async</span> <span class=p>(</span><span class=nx>message</span><span class=p>,</span> <span class=nx>messageConsumer</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>          <span class=kr>await</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(</span><span class=nx>resolve</span><span class=p>,</span> <span class=mi>10</span><span class=p>));</span>
</span></span><span class=line><span class=cl>          <span class=nx>consumer1Recv</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>          <span class=kr>await</span> <span class=nx>messageConsumer</span><span class=p>.</span><span class=nx>acknowledge</span><span class=p>(</span><span class=nx>message</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span></code></pre></div><p>The message listener does not wait for the completion of the user JS function. This is because the asynchronous JS function returns a promise object and executes the logic asynchronously. As a result, step 5 is actually waiting for the promise object instead of the completion of the user JS function.</p><p>This blog post discusses how to resolve this issue. We need to first determine when the user JS function has completed and then figure out how to set a guard in the C++ native code to wait until the user JS function has fully completed. And we will also talk about how to handle errors properly.</p><h2 id=the-workflow-for-invoking-the-js-function>The Workflow for Invoking the JS Function<a hidden class=anchor aria-hidden=true href=#the-workflow-for-invoking-the-js-function>#</a></h2><p>Let&rsquo;s start by taking a look at the overview of the workflow for invoking the JS function.
We added a configure method to allow users to pass their JS callback function to the C++ native code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Napi</span><span class=o>::</span><span class=n>Function</span> <span class=n>jsFunction</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Napi</span><span class=o>::</span><span class=n>ThreadSafeFunction</span> <span class=n>callback</span> <span class=o>=</span> <span class=n>Napi</span><span class=o>::</span><span class=n>ThreadSafeFunction</span><span class=o>::</span><span class=n>New</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>consumerConfig</span><span class=p>.</span><span class=n>Env</span><span class=p>(),</span> <span class=n>jsFunction</span><span class=p>,</span> <span class=s>&#34;Listener Callback&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=mi>1</span><span class=p>,</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=p>)</span><span class=nb>NULL</span><span class=p>,</span> <span class=n>FinalizeListenerCallback</span><span class=p>,</span> <span class=n>listener</span><span class=p>);</span>
</span></span></code></pre></div><p>Assuming that <code>jsFunction</code> is passed from the user JS code, we create a <code>ThreadSafeFunction</code> for this <code>jsFunction</code>. The <code>Napi::ThreadSafeFunction</code> type provides APIs for threads to communicate with the Nodejs&rsquo;s main thread to invoke JavaScript functions on their behalf. [<a href=https://github.com/nodejs/node-addon-api/blob/main/doc/threadsafe_function.md#threadsafefunction>0</a>] For more documentation on <code>Napi::ThreadSafeFunction::New</code>, check <a href=https://github.com/nodejs/node-addon-api/blob/main/doc/threadsafe_function.md#new>here</a>.</p><p>When a triggered event occurs, we invoke the <code>callback</code> that we created above in our implementation of the message listener:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>callback</span><span class=p>.</span><span class=n>BlockingCall</span><span class=p>(</span><span class=n>dataPtr</span><span class=p>,</span> <span class=n>MessageListenerProxy</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>callback</span><span class=p>.</span><span class=n>Release</span><span class=p>();</span>
</span></span></code></pre></div><p>When calling the <code>BlockingCall</code>, the current thread will be blocked until the actual invoking of the JS function becomes available in the queue inside the Node.js thread. [<a href=https://github.com/nodejs/node-addon-api/blob/main/doc/threadsafe_function.md#blockingcall--nonblockingcall>1</a>] The <code>MessageListenerProxy</code> is a pointer to a function that we will call the internal JS function.</p><p>Here is the simplified implementation of our <code>MessageListenerProxy</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>MessageListenerProxy</span><span class=p>(</span><span class=n>Napi</span><span class=o>::</span><span class=n>Env</span> <span class=n>env</span><span class=p>,</span> <span class=n>Napi</span><span class=o>::</span><span class=n>Function</span> <span class=n>jsCallback</span><span class=p>,</span> <span class=n>MessageListenerProxyData</span> <span class=o>*</span><span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Napi</span><span class=o>::</span><span class=n>Object</span> <span class=n>msg</span> <span class=o>=</span> <span class=n>Message</span><span class=o>::</span><span class=n>NewInstance</span><span class=p>({},</span> <span class=n>data</span><span class=o>-&gt;</span><span class=n>cMessage</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>jsCallback</span><span class=p>.</span><span class=n>Call</span><span class=p>({</span> <span class=n>msg</span> <span class=p>}});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above is an overview of the workflow. The issue arises from <code>jsCallback.Call({ msg }});</code>. When the <code>jsCallback</code> is an asynchronous function, the <code>jsCallback.Call({ msg }})</code> will return immediately instead of waiting for the user function to complete. [<a href=https://github.com/nodejs/node-addon-api/blob/main/doc/function.md#call>2</a>]</p><h2 id=use-nodejs-promise-to-reach-the-point-where-the-user-function-is-finished>Use Nodejs <code>Promise</code> to reach the point where the user function is finished<a hidden class=anchor aria-hidden=true href=#use-nodejs-promise-to-reach-the-point-where-the-user-function-is-finished>#</a></h2><p>Fortunately, the <code>jsCallback.Call</code> will return a Node.js <code>Promise</code> object for us to handle if the function is asynchronous. We can handle the <code>Promise</code> the same way we did in JavaScript. There is an inner method in <code>Promise</code> called <code>then</code>. We can use it to register a callback for the <code>Promise</code>.</p><p>Here is how to achieve it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Napi</span><span class=o>::</span><span class=n>Value</span> <span class=n>ret</span> <span class=o>=</span> <span class=n>jsCallback</span><span class=p>.</span><span class=n>Call</span><span class=p>({</span><span class=n>msg</span><span class=p>});</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>ret</span><span class=p>.</span><span class=n>IsPromise</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Napi</span><span class=o>::</span><span class=n>Promise</span> <span class=n>promise</span> <span class=o>=</span> <span class=n>ret</span><span class=p>.</span><span class=n>As</span><span class=o>&lt;</span><span class=n>Napi</span><span class=o>::</span><span class=n>Promise</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>Napi</span><span class=o>::</span><span class=n>Value</span> <span class=n>thenValue</span> <span class=o>=</span> <span class=n>promise</span><span class=p>.</span><span class=n>Get</span><span class=p>(</span><span class=s>&#34;then&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>Napi</span><span class=o>::</span><span class=n>Function</span> <span class=n>then</span> <span class=o>=</span> <span class=n>thenValue</span><span class=p>.</span><span class=n>As</span><span class=o>&lt;</span><span class=n>Napi</span><span class=o>::</span><span class=n>Function</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>Napi</span><span class=o>::</span><span class=n>Function</span> <span class=n>callback</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>      <span class=n>Napi</span><span class=o>::</span><span class=n>Function</span><span class=o>::</span><span class=n>New</span><span class=p>(</span><span class=n>env</span><span class=p>,</span> <span class=p>[](</span><span class=k>const</span> <span class=n>Napi</span><span class=o>::</span><span class=n>CallbackInfo</span> <span class=o>&amp;</span><span class=n>info</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>          <span class=c1>// the point where the user function is finished
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=n>then</span><span class=p>.</span><span class=n>Call</span><span class=p>(</span><span class=n>promise</span><span class=p>,</span> <span class=p>{</span><span class=n>callback</span><span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We need to check if the return value is a <code>Promise</code> or not to also handle the case of a synchronous function. We create a new <code>Napi::Function</code> as a callback. Then we register it to <code>Promise.then()</code>.</p><h2 id=use-stdpromise-to-wait-for-the-result>Use <code>std::promise</code> to Wait for the Result<a hidden class=anchor aria-hidden=true href=#use-stdpromise-to-wait-for-the-result>#</a></h2><p>Now, we can use <code>std::promise</code> to set up a guard for it.
Here is a simple sample code to set up a guard:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>promise</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span> <span class=n>promise</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>future</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span> <span class=n>future</span> <span class=o>=</span> <span class=n>promise</span><span class=p>.</span><span class=n>get_future</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>Napi</span><span class=o>::</span><span class=n>Function</span> <span class=n>callback</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>      <span class=n>Napi</span><span class=o>::</span><span class=n>Function</span><span class=o>::</span><span class=n>New</span><span class=p>(</span><span class=n>env</span><span class=p>,</span> <span class=p>[</span><span class=o>&amp;</span><span class=n>promise</span><span class=p>](</span><span class=k>const</span> <span class=n>Napi</span><span class=o>::</span><span class=n>CallbackInfo</span> <span class=o>&amp;</span><span class=n>info</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>          <span class=n>promise</span><span class=p>.</span><span class=n>set_value</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=n>then</span><span class=p>.</span><span class=n>Call</span><span class=p>(</span><span class=n>promise</span><span class=p>,</span> <span class=p>{</span><span class=n>callback</span><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Will be blocked until the jsCallback is finished.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>future</span><span class=p>.</span><span class=n>wait</span><span class=p>();</span>
</span></span></code></pre></div><p>It looks like we can now wait for the result of the asynchronous JS function. However, this code is also incorrect. It will block the entire main thread of the Node.js! Running this code will block your entire program.</p><h2 id=dont-wait-in-the-nodejs-thread>Don&rsquo;t Wait in the Node.js Thread<a hidden class=anchor aria-hidden=true href=#dont-wait-in-the-nodejs-thread>#</a></h2><p>To fix the above problem, we need to understand the thread context changes throughout the workflow.</p><p>The message listener is running on the thread coming from the listener thread pool inside the Pulsar C client library. Then we use <code>ThreadSafeFunction</code> to change the calling context into a more thread-safe context: the Node.js main thread context. We are calling the inner JS function on the Node.js main thread. Therefore, we need to wait for the <code>std::future</code> outside the Node.js main thread.</p><p>We need to move the guard that we set above to the message listener implementation.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>promise</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span> <span class=n>promise</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>future</span><span class=o>&lt;</span><span class=kt>void</span><span class=o>&gt;</span> <span class=n>future</span> <span class=o>=</span> <span class=n>promise</span><span class=p>.</span><span class=n>get_future</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>MessageListenerProxyData</span> <span class=o>*</span><span class=n>dataPtr</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>new</span> <span class=n>MessageListenerProxyData</span><span class=p>(</span><span class=n>cMessage</span><span class=p>,</span> <span class=p>[</span><span class=o>&amp;</span><span class=n>promise</span><span class=p>]()</span> <span class=p>{</span> <span class=n>promise</span><span class=p>.</span><span class=n>set_value</span><span class=p>();</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=n>listenerCallback</span><span class=o>-&gt;</span><span class=n>callback</span><span class=p>.</span><span class=n>BlockingCall</span><span class=p>(</span><span class=n>dataPtr</span><span class=p>,</span> <span class=n>MessageListenerProxy</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>listenerCallback</span><span class=o>-&gt;</span><span class=n>callback</span><span class=p>.</span><span class=n>Release</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>future</span><span class=p>.</span><span class=n>wait</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>delete</span> <span class=n>dataPtr</span><span class=p>;</span>
</span></span></code></pre></div><p>We use <code>MessageListenerProxyData</code> to pass the lambda callback to <code>MessageListenerProxy</code>. And in <code>MessageListenerProxy</code>, we can simply call this callback:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>MessageListenerProxy</span><span class=p>(</span><span class=n>Napi</span><span class=o>::</span><span class=n>Env</span> <span class=n>env</span><span class=p>,</span> <span class=n>Napi</span><span class=o>::</span><span class=n>Function</span> <span class=n>jsCallback</span><span class=p>,</span> <span class=n>MessageListenerProxyData</span> <span class=o>*</span><span class=n>data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Napi</span><span class=o>::</span><span class=n>Object</span> <span class=n>msg</span> <span class=o>=</span> <span class=n>Message</span><span class=o>::</span><span class=n>NewInstance</span><span class=p>({},</span> <span class=n>data</span><span class=o>-&gt;</span><span class=n>cMessage</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>Napi</span><span class=o>::</span><span class=n>Value</span> <span class=n>ret</span> <span class=o>=</span> <span class=n>jsCallback</span><span class=p>.</span><span class=n>Call</span><span class=p>({</span><span class=n>msg</span><span class=p>,</span> <span class=n>consumer</span><span class=o>-&gt;</span><span class=n>Value</span><span class=p>()});</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>ret</span><span class=p>.</span><span class=n>IsPromise</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Napi</span><span class=o>::</span><span class=n>Promise</span> <span class=n>promise</span> <span class=o>=</span> <span class=n>ret</span><span class=p>.</span><span class=n>As</span><span class=o>&lt;</span><span class=n>Napi</span><span class=o>::</span><span class=n>Promise</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Napi</span><span class=o>::</span><span class=n>Value</span> <span class=n>thenValue</span> <span class=o>=</span> <span class=n>promise</span><span class=p>.</span><span class=n>Get</span><span class=p>(</span><span class=s>&#34;then&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>thenValue</span><span class=p>.</span><span class=n>IsFunction</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>Napi</span><span class=o>::</span><span class=n>Function</span> <span class=n>then</span> <span class=o>=</span> <span class=n>thenValue</span><span class=p>.</span><span class=n>As</span><span class=o>&lt;</span><span class=n>Napi</span><span class=o>::</span><span class=n>Function</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=n>Napi</span><span class=o>::</span><span class=n>Function</span> <span class=n>callback</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>          <span class=n>Napi</span><span class=o>::</span><span class=n>Function</span><span class=o>::</span><span class=n>New</span><span class=p>(</span><span class=n>env</span><span class=p>,</span> <span class=p>[</span><span class=n>data</span><span class=p>](</span><span class=k>const</span> <span class=n>Napi</span><span class=o>::</span><span class=n>CallbackInfo</span> <span class=o>&amp;</span><span class=n>info</span><span class=p>)</span> <span class=p>{</span> <span class=n>data</span><span class=o>-&gt;</span><span class=n>callback</span><span class=p>();</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>      <span class=n>then</span><span class=p>.</span><span class=n>Call</span><span class=p>(</span><span class=n>promise</span><span class=p>,</span> <span class=p>{</span><span class=n>callback</span><span class=p>});</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>data</span><span class=o>-&gt;</span><span class=n>callback</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Note that we also set the guard even if the <code>jsCallback</code> is a synchronous function. Because we can&rsquo;t determine if it&rsquo;s synchronous or not before executing the <code>BlockingCall</code>. So we still need to execute <code>data->callback()</code> when it&rsquo;s synchronous.</p><h2 id=error-handling>Error handling<a hidden class=anchor aria-hidden=true href=#error-handling>#</a></h2><p>Similarly, we can also use <code>promise.catch()</code> to handle the error that is thrown from the Nodejs code asynchronously.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Napi</span><span class=o>::</span><span class=n>Function</span> <span class=n>catchFunc</span> <span class=o>=</span> <span class=n>promise</span><span class=p>.</span><span class=n>Get</span><span class=p>(</span><span class=s>&#34;catch&#34;</span><span class=p>).</span><span class=n>As</span><span class=o>&lt;</span><span class=n>Napi</span><span class=o>::</span><span class=n>Function</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>ret</span> <span class=o>=</span> <span class=n>catchFunc</span><span class=p>.</span><span class=n>Call</span><span class=p>(</span><span class=n>promise</span><span class=p>,</span> <span class=p>{</span><span class=n>Napi</span><span class=o>::</span><span class=n>Function</span><span class=o>::</span><span class=n>New</span><span class=p>(</span><span class=n>env</span><span class=p>,</span> <span class=p>[](</span><span class=k>const</span> <span class=n>Napi</span><span class=o>::</span><span class=n>CallbackInfo</span> <span class=o>&amp;</span><span class=n>info</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                             <span class=n>Napi</span><span class=o>::</span><span class=n>Error</span> <span class=n>error</span> <span class=o>=</span> <span class=n>info</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>As</span><span class=o>&lt;</span><span class=n>Napi</span><span class=o>::</span><span class=n>Error</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                             <span class=n>LOG_INFO</span><span class=p>(</span><span class=n>error</span><span class=p>.</span><span class=n>what</span><span class=p>())</span>
</span></span><span class=line><span class=cl>                             <span class=n>data</span><span class=o>-&gt;</span><span class=n>callback</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                           <span class=p>})});</span>
</span></span></code></pre></div><p>Here, we use <code>info[0].As&lt;Napi::Error>()</code> to get the first parameter of <code>promise.catch()</code> which is of type <code>Error</code>. <code>error.what()</code> will return the message of the error.</p><p>Finally, we can optimize our code by moving the <code>data->callback</code> to the <code>promise.finally()</code> to avoid calling the <code>data->callback</code> twice:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>promise</span> <span class=o>=</span> <span class=n>ret</span><span class=p>.</span><span class=n>As</span><span class=o>&lt;</span><span class=n>Napi</span><span class=o>::</span><span class=n>Promise</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>Napi</span><span class=o>::</span><span class=n>Function</span> <span class=n>finallyFunc</span> <span class=o>=</span> <span class=n>promise</span><span class=p>.</span><span class=n>Get</span><span class=p>(</span><span class=s>&#34;finally&#34;</span><span class=p>).</span><span class=n>As</span><span class=o>&lt;</span><span class=n>Napi</span><span class=o>::</span><span class=n>Function</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>finallyFunc</span><span class=p>.</span><span class=n>Call</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>promise</span><span class=p>,</span> <span class=p>{</span><span class=n>Napi</span><span class=o>::</span><span class=n>Function</span><span class=o>::</span><span class=n>New</span><span class=p>(</span><span class=n>env</span><span class=p>,</span> <span class=p>[</span><span class=n>data</span><span class=p>](</span><span class=k>const</span> <span class=n>Napi</span><span class=o>::</span><span class=n>CallbackInfo</span> <span class=o>&amp;</span><span class=n>info</span><span class=p>)</span> <span class=p>{</span> <span class=n>data</span><span class=o>-&gt;</span><span class=n>callback</span><span class=p>();</span> <span class=p>})});</span>
</span></span></code></pre></div><p>In conclusion, properly handling asynchronous code in a C++ addon for a Node.js application can be tricky. It requires understanding the thread context changes and properly managing Promise objects and guards. By using ThreadSafeFunction and std::promise, we can ensure that our addon is thread-safe and does not block the Node.js main thread. Properly handling asynchronous code in a C++ addon is essential for creating efficient and reliable Node.js applications.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zikeyang.com/tags/nodejs/>nodejs</a></li><li><a href=https://zikeyang.com/tags/c++/>c++</a></li><li><a href=https://zikeyang.com/tags/pulsar/>pulsar</a></li></ul><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Call a Nodejs Async Function from C++ Native Code on twitter" href="https://twitter.com/intent/tweet/?text=Call%20a%20Nodejs%20Async%20Function%20from%20C%2b%2b%20Native%20Code&amp;url=https%3a%2f%2fzikeyang.com%2fposts%2fcall-a-nodejs-async-function-from-napi-native-code%2f&amp;hashtags=nodejs%2cc%2b%2b%2cpulsar"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Call a Nodejs Async Function from C++ Native Code on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fzikeyang.com%2fposts%2fcall-a-nodejs-async-function-from-napi-native-code%2f&amp;title=Call%20a%20Nodejs%20Async%20Function%20from%20C%2b%2b%20Native%20Code&amp;summary=Call%20a%20Nodejs%20Async%20Function%20from%20C%2b%2b%20Native%20Code&amp;source=https%3a%2f%2fzikeyang.com%2fposts%2fcall-a-nodejs-async-function-from-napi-native-code%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Call a Nodejs Async Function from C++ Native Code on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fzikeyang.com%2fposts%2fcall-a-nodejs-async-function-from-napi-native-code%2f&title=Call%20a%20Nodejs%20Async%20Function%20from%20C%2b%2b%20Native%20Code"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Call a Nodejs Async Function from C++ Native Code on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzikeyang.com%2fposts%2fcall-a-nodejs-async-function-from-napi-native-code%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Call a Nodejs Async Function from C++ Native Code on whatsapp" href="https://api.whatsapp.com/send?text=Call%20a%20Nodejs%20Async%20Function%20from%20C%2b%2b%20Native%20Code%20-%20https%3a%2f%2fzikeyang.com%2fposts%2fcall-a-nodejs-async-function-from-napi-native-code%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Call a Nodejs Async Function from C++ Native Code on telegram" href="https://telegram.me/share/url?text=Call%20a%20Nodejs%20Async%20Function%20from%20C%2b%2b%20Native%20Code&amp;url=https%3a%2f%2fzikeyang.com%2fposts%2fcall-a-nodejs-async-function-from-napi-native-code%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://zikeyang.com>Just for fun</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>